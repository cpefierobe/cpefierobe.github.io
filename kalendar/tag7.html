<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Jeu de Billard Minimaliste</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
  </head>
  <body>
    <script>
// --- CONFIG ---
let tableW = 400;
let tableH = 600;
let holeX, holeY, holeR = 22;

let ballWhite, ballRed;
let dragging = false;
let dragStart;
let gameState = "play";

class Ball {
  constructor(x, y, r) {
    this.pos = createVector(x, y);
    this.vel = createVector(0, 0);
    this.r = r;
  }
  update() {
    this.pos.add(this.vel);
    this.vel.mult(0.985);
  }
}

// empêcher le scroll sur mobile
document.addEventListener('touchmove', e => e.preventDefault(), { passive: false });

function setup() {
  createCanvas(tableW, tableH);
  resetGame();
}

function resetGame() {
  holeX = width * 0.8;
  holeY = height * 0.25;

  ballWhite = new Ball(width * 0.3, height * 0.8, 14);
  ballRed   = new Ball(width * 0.55, height * 0.45, 14);

  gameState = "play";
}

function draw() {
  background(255);

  noFill();
  stroke(0);
  strokeWeight(2);
  ellipse(width / 2, height / 2, tableW - 20, tableH - 20);

  fill(0);
  noStroke();
  ellipse(holeX, holeY, holeR * 2);

  if (gameState === "play") {
    ballWhite.update();
    ballRed.update();

    collideWithEllipse(ballWhite);
    collideWithEllipse(ballRed);

    collideBalls(ballWhite, ballRed);

    if (p5.Vector.dist(ballRed.pos, createVector(holeX, holeY)) < holeR) gameState = "win";
    if (p5.Vector.dist(ballWhite.pos, createVector(holeX, holeY)) < holeR) gameState = "lose";
  }

  drawBalls();

  if (dragging && gameState === "play") {
    stroke(0);
    line(ballWhite.pos.x, ballWhite.pos.y, mouseX, mouseY);
  }

  if (gameState !== "play") {
    fill(0);
    textAlign(CENTER, CENTER);
    textSize(32);
    text(gameState === "win" ? "Gagné !" : "Perdu !", width / 2, height / 2);
    textSize(14);
    text("Cliquez pour recommencer", width / 2, height / 2 + 40);
  }
}

function drawBalls() {
  stroke(0);
  fill(255);
  ellipse(ballWhite.pos.x, ballWhite.pos.y, ballWhite.r * 2);

  fill(255,0,0);
  stroke(0);
  ellipse(ballRed.pos.x, ballRed.pos.y, ballRed.r * 2);
}

function mousePressed() {
  if (gameState !== "play") {
    resetGame();
    return;
  }

  if (dist(mouseX, mouseY, ballWhite.pos.x, ballWhite.pos.y) < ballWhite.r) {
    dragging = true;
    dragStart = createVector(mouseX, mouseY);
  }
}

function mouseReleased() {
  if (dragging) {
    let dragEnd = createVector(mouseX, mouseY);
    let force = p5.Vector.sub(dragStart, dragEnd).mult(0.06);
    ballWhite.vel.add(force);
  }
  dragging = false;
}

function collideBalls(b1, b2) {
  let d = p5.Vector.dist(b1.pos, b2.pos);
  let minDist = b1.r + b2.r;
  if (d < minDist) {
    let n = p5.Vector.sub(b2.pos, b1.pos).normalize();
    let overlap = minDist - d;
    b1.pos.add(n.copy().mult(-overlap / 2));
    b2.pos.add(n.copy().mult(overlap / 2));

    let v1 = b1.vel.dot(n);
    let v2 = b2.vel.dot(n);
    b1.vel.add(n.copy().mult(v2 - v1));
    b2.vel.add(n.copy().mult(v1 - v2));
  }
}

function collideWithEllipse(ball) {
  let nx = (ball.pos.x - width / 2) / ((tableW - 20) / 2);
  let ny = (ball.pos.y - height / 2) / ((tableH - 20) / 2);
  if (nx * nx + ny * ny > 1) {
    let n = createVector(nx, ny).normalize();
    ball.vel.sub(n.mult(2 * ball.vel.dot(n)));
    ball.pos.sub(n.setMag(3));
  }
}
</script>
  </body>
</html>

